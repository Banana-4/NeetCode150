# Find Duplicate Number:

## Problem:
In array of integers containing n + 1 numbers and each nubmer is in range [1,n] there is one repeated number.
Find and return it.

## Constrains:
Constant space, and no array modification.

## Input:
### Step 1
1. Array of integers in range [1,n],
2. n is the size of the array - 1, the number of unique integers
3. The size of the array is n + 1, there is one duplicate.

### Step 2:
1. Each number is also a index of the array, the array contains its own indexes.
2. One index is missing, there is duplicate number.

### Step 3:
1. The array contents are like the next pointer of singly linked list, in the sense that they point to the next node in line.
2. The head of the list would be the integer at positon 0 in the array.

### Step 4:
1. When the array[0] integer is used as the start of a traversal, not all numbers can be reached.
2. Two slots point to the same slot, two next pointers point to the same node.
3. That means a cycle starts at the duplicate number.

### Conclusion:
The input can be viewed as a singly linked list with a cycle that has no values only next pointers.


## Output:

A number that is a duplicate.


## Brute force solution:
Check all possible pairs of numbers to find the duplicate nubmer.
Compares all numbers to other numbers, using two loops.

### Time Complexity:
O(n^2)

### Space Complexity:
O(1)

### Code:
``` python
for i in numbers:
    for j in numbers[i + 1]:
        if numbers[i] == numbers[j]:
            return numbers[i]
```


## Solution with Floyd's Algorithm:
Two step solution:
1. The solution uses Floyd's algorithm to put a pointer into a cycle.
2. Find the start of the cycle:
   - Set the slow = head, nums[0]
   - start moving both slow and fast pointers forward
   - when slow == fast, the start of the cycle is found.
return the slow index.

The second step while always find the duplicate for two reasons:
1. Fast and slow will never be at the same node, because fast is always one node ahead of slow.
2. They can only have the same value if two nodes lead  to two different nodes that have the same value, all other nodes lead to unique values.

### Time Complexity:
O(n)

### Space Complexity:
O(1)

