# LeetCode 146. LRU Cache

## Problem:

Implement a Data Structure that follows the constrains of a least recently used cache.

### Operations:
1. LRUCache(int capacity) - init the DS with capacity that is  greater then 0.
2. int get(int key) - Return the value of the key if the key exists, otherwise return -1. 
3. void put(int key, int value) - Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. 

### Constrains:
 1. get and put have O(1) average time complexity.
 2. 1 <= capacity <= 3000
 3. 0 <= key <= 10^4
 4. 0 <= value <= 10^5
 5. At most 2 * 10^5 calls will be made to get and put
 
## Data:

### Step 1 - what data to i have:
1. key-value pair just like in hash maps.
2. Uses for each keys.
3. When a key is access or added it becomes the most recently used.
4. The memory space for key-values is limited to capacity.
5. Adding a new key when at max capacity evicts the Least Reacently used key from the DS. 
6. Least Recently used means the used last in time.
7. Most recent is the last item accessed.

8. Invariant: The key-value pairs are going to be always sorted based on the time accessed.

### Step 2:

1. Maping: key->node, O(1) time maping is required for get function.
2. Because the last used is the most recently used item it needs to move to the end.
3. The other key-values keep theire relative order.
4. The updating of the order needs to happen in O(1) time.
5. Evicting of the LRU needs to be done in O(1) time.
6. A new node is added to the end to keep the order and it needs to be done in O(1) time.
5. Doubly Linked List is the data structure that has O(1) end point manipulations.


### Step 3:



#### Mapping:
```
[key][key][key][key][key][key][key]
  |
  |
 [node]

least recently used -------> most recently used
 
 []<-->[]<-->[]<-->[]<-->[] 

Full capacity insert:
            |
  [head] <- | -> []<-->[]<-->[]<-->[]
            |
   
   []<-->[]<-->[]<-->[]
   
   []<-->[]<-->[]<-->[]<-->[new node]
   
Get exsisting node:
[]<-->[node]<-->[]<-->[]<-->[]

[]<-->[]<-->[]<-->[]<-->[node]

```
### Data Strucutre members:

key-node map.
capacity.
size
head
tail

## Invariant:
List is always in sorted order based on the last time used.
